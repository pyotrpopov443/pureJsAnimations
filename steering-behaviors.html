<!doctype html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>SteeringBehaviors</title>
</head>
<body>

<div class="container"></div>

<style>
	* {margin: 0;}

	.container {
		position: absolute;
		width: 100vw;
		height: 100vh;
	}

	canvas {
		position: absolute;
	}
</style>

<script>
	let backgroundColor = '#f6f6f6';
	let fontColor = '#333333';
	let mouseX = 0;
	let mouseY = 0;
	let canvas = document.createElement('canvas');
	let container = document.querySelector('.container');
	canvas.height = container.getBoundingClientRect().height;
	canvas.width = container.getBoundingClientRect().width;
	container.append(canvas);
	let ctx = canvas.getContext('2d');
	ctx.textBaseline = "middle";
	ctx.textAlign = "center";

	let mouseSize = 50;
	let particleRadius = 8;

	function Vector(x = 0, y = 0) {
		this.x = x;
		this.y = y;
	}
	Vector.prototype.add = function(vector) {
		this.x += vector.x;
		this.y += vector.y;
	}
	Vector.prototype.mult = function(lambda) {
		this.x *= lambda;
		this.y *= lambda;
	}
	Vector.prototype.mag = function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	Vector.prototype.setMag = function(newMag) {
		let curMag = this.mag();
		this.x *= newMag / curMag;
		this.y *= newMag / curMag;
	}
	Vector.prototype.limit = function(maxMag) {
		if (this.mag() > maxMag) {
			this.setMag(maxMag);
		}
	}
	function vecSub(vector1, vector2) {
		return new Vector(vector1.x - vector2.x, vector1.y - vector2.y);
	}

	function Particle(x,y) {
		this.pos = new Vector(canvas.width/2, canvas.height/2);
		this.target = new Vector(x, y);
		this.vel = new Vector();
		this.r = particleRadius;
		this.maxspeed = 15;
		this.maxforce = 1.5;
	}
	Particle.prototype.update = function() {
		let arrive = this.arrive(this.target);
		let flee = this.flee(new Vector(mouseX, mouseY));
		flee.mult(5);

		this.pos.add(this.vel);
		this.vel.add(arrive);
		this.vel.add(flee);
	}
	Particle.prototype.show = function() {
		fill(fontColor);
		circle(this.pos.x, this.pos.y, this.r);
	}
	Particle.prototype.arrive = function(target) {
		let desired = vecSub(target, this.pos);
		let d = desired.mag();
		let speed = this.maxspeed;
		if (d < 100) {
			speed = map(d, 0, 100, 0, this.maxspeed);
		}
		desired.setMag(speed);
		let steer = vecSub(desired, this.vel);
		steer.limit(this.maxforce);
		return steer;
	}
	Particle.prototype.flee = function(target) {
		let desired = vecSub(target, this.pos);
		let d = desired.mag();
		if (d < mouseSize) {
			desired.setMag(this.maxspeed);
			desired.mult(-1);
			let steer = vecSub(desired, this.vel);
			steer.limit(this.maxforce);
			return steer;
		} else {
			return new Vector();
		}
	}

	let particles;

	function setup() {
		font("bold 200px sans-serif");
		let points = textToPoints("4 0 4", canvas.width/2, canvas.height/2, particleRadius * 2);
		particles = [];
		points.forEach(p => {
			particles.push(new Particle(p.x, p.y))
		});
	}

	function draw() {
		background(backgroundColor);
		particles.forEach(particle => {
			particle.update();
			particle.show();
		});
	}

	setup()
	draw()
	setInterval(draw, 17);

	function background(color) {
		fill(color);
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	}

	function fill(color) {
		ctx.fillStyle = color;
	}

	function font(options) {
		ctx.font = options;
	}

	function circle(x, y, radius) {
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, 2 * Math.PI, true)
		ctx.fill();
		ctx.closePath();
	}

	function textToPoints(txt, x, y, spacing) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.strokeText(txt, x, y);

		let points = [];
		let data32 = new Uint32Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data.buffer);
		for(let i = 0; i < data32.length; i++) {
			if (data32[i] & 0xff000000) {
				let vec = new Vector(i % canvas.width, i / canvas.width);
				if (enoughSpace(vec)) {
					points.push(vec);
				}
			}
		}

		function enoughSpace(vec) {
			for (let point of points) {
				if (vecSub(vec, point).mag() < spacing) {
					return false;
				}
			}
			return true;
		}

		return points;
	}

	function map(x, inputFrom, inputTo, outputFrom, outputTo) {
		return outputFrom + ((outputTo - outputFrom) / (inputTo - inputFrom)) * (x - inputFrom);
	}

	window.addEventListener('mousemove', (e) => {
		mouseX = e.clientX - canvas.getBoundingClientRect().x;
		mouseY = e.clientY - canvas.getBoundingClientRect().y;
	})
	window.addEventListener('touchmove', (e) => {
		mouseX = e.touches[0].clientX - canvas.getBoundingClientRect().x;
		mouseY = e.touches[0].clientY - canvas.getBoundingClientRect().y;
	})
</script>

</body>
</html>